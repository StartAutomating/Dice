<!-- Generated with EZOut 2.0.6: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>Dice</Name>
    <Members>
      <ScriptMethod>
        <Name>Roll</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Rolls the dice.
.DESCRIPTION
    Rolls a dice any number of sides any number of times.
#&gt;
param(
# The number of sides on the dice.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('Side','Number')]
[int]$Sides,

# The number of rolls of the dice.
[Alias('Rolls','Roll')]
[int]$RollCount = 1
)



if ($sides) {
    $thisDiceExists = @($dice.DB.Tables["Dice"].Select("Sides = $sides"))
    if (-not $thisDiceExists) {
        $thisDiceExists = (New-Dice -Sides $sides)
    }
    foreach ($n in 1..$rollCount) {
        $thisDiceExists.Roll()
    }                
    continue
}

if (-not $this.Sides) {
    foreach ($die in $dice.DB.Tables['Dice']) {
        foreach ($n in 1..$rollCount) {
            $die.Roll() 
        }            
    }
} else {        
    $rollTable = $dice.DB.Tables[$this.Name]
    foreach ($n in 1..$rollCount) {
        $diceRoll = $rollTable.NewRow()
        $diceRoll.Sides = $this.Sides
        $diceRoll.Roll = (Get-Random -Minimum 1 -Maximum ($this.Sides + 1)) -as [double]
        $rollTable.Rows.Add($diceRoll)
        $diceRoll.pstypenames.insert(0,'Dice.Roll')
        $diceRoll
    }        
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>DB</Name>
        <GetScriptBlock>
                        param()


# If $dice is a PSModuleInfo object and it does not have a '.DB' property,
if ($dice -is [Management.Automation.PSModuleInfo] -and (-not $dice.'.DB')) {
    # then create a new DataSet object named 'Dice'.    
    $diceDB = [Data.DataSet]::new('Dice')
    $dice.psobject.properties.add([psnoteproperty]::new('.DB', $diceDB), $true)
    # Create a new DataTable object named 'Dice' and add it to the DataSet object.
    $diceTable = $diceDB.Tables.Add('Dice')
    # A dice will have a name and a number of sides.
    $diceTable.Columns.AddRange(@(
        [Data.DataColumn]::new('Name', [string], '', 'Attribute')
        [Data.DataColumn]::new('Sides', [int], '', 'Attribute')
    ))
    
    # The sides of a dice will be the primary key.
    $diceTable.PrimaryKey = @($diceTable.Columns['Sides'])
    # The chance of rolling a side will be 1 divided by the number of sides,
    # and will be calculated using an expression property.
    $chanceColumn = $diceTable.Columns.Add('Chance', [double], '1/Sides')    
    $chanceColumn.ColumnMapping = 'Attribute'    
    
    # Create a few dice objects.
    $null = @(
        New-Dice -Name 'coin' -Sides 2 # -Face 'ü¶∏','ü¶π'       
        New-Dice -Name 'Six-Sided-Dice' -Sides 6 # -Faces '‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'        
        New-Dice -Name 'D20' -Sides 20
    )
    # Accept the changes to the Dice Table.
    $diceTable.AcceptChanges()
}
# Return the Dice Database (all of the code above should only run once per module load).
return $dice.'.DB'



                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>RollCount</Name>
        <GetScriptBlock>
                        return $this.RollTable.Rows.Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>RollTable</Name>
        <GetScriptBlock>
                        if ($dice.DB.Tables[$this.Name]) {
    return ,$dice.DB.Tables[$this.Name]
}
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
</Types>